\documentclass[times, utf8, diplomski, numeric]{fer}
\usepackage{booktabs}
\usepackage{tabu, multirow}
\usepackage{tabularx}
\usepackage{float}
\usepackage{pdfpages}

\begin{document}

\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$-$}

% TODO: Navedite broj rada.
\thesisnumber{1995}

% TODO: Navedite naslov rada.
\title{Proširenje LTZVisor monitora virtualnih strojeva \\za višejezgrene procesore}

% TODO: Navedite vaše ime i prezime.
\author{Magdalena Halusek}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
% \izvornik
\includepdf[pages=-,pagecommand={}]{0688_001.pdf}

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}
Neke od važnih odrednica ugradbenih računala su pouzdanost, predvidljivost i rad u stvarnom vremenu.
Povećanjem popularnosti IoT (engl. \textit{Internet of Things}) uređaja u industriji, počinje se isticati
još jedna dodatna karakteristika, a radi se o sigurnosti uređaja. Kako bi se uređaji u industriji osigurali,
ARM već dugi niz godina daje podršku Cortex-A procesorima \textit{TrustZone} sigurnosnim ekstenzijama.
Izlaskom M profila nove ARMv8 arhitekture, pojavila se i posebno razvijena \textit{TrustZone-M} sigurnosna
podrška Cortex-M procesora. Iako je \textit{TrustZone-M} sigurnosna ekstenzija razvijena ispočetka konkretno
za mikrokontrolere, krajnja funkcionalnost je slična onoj koju pruža \textit{TrustZone} ekstenzija Cortex-A
procesora.\\
U ovom radu će biti opisana \textit{TrustZone} sigurnosna ekstenzija ZedBoard platforme koja implementira
Cortex-A9 procesor s dvije jezgre te sustav za procesiranje (engl. \textit{Processing System}, PS) i programabilnu
logiku (PL). Kao primjer maksimalnog iskorištenja \textit{TrustZone} sigurnosne
ekstenzije, bit će prikazan LTZVisor monitor virtualnih strojeva (engl. \textit{hypervisor} ili engl.
\textit{Virtual Machine Monitor}). LTZVisor omogućava virtualizaciju u ugradbenim računalima, odnosno konkurentno
izvođenje dva operacijska sustava na jednoj jezgri procesora. Pojavom IoT uređaja u industriji, pojavila
se i sve veća potreba za virtualizacijom zbog potrebe za karakteristikama operacijskih sustava za rad u stvarnom
vremenu i operacijskih sustava opće namjene. Specifičnije, karakteristike operacijskog sustava za rad u
stvarnom vremenu koje su potrebne su odziv u stvarnom vremenu, determinizam i pouzdanost. Operacijski
sustav opće namjene je često tražen zbog dobre mrežne podrške koju nudi. U nastavku će biti opisano kako
\textit{TrustZone} doprinosi izolaciji između navedenih operacijskih sustava. Pošto je LTZVisor monitor
virtualnih strojeva namijenjen jednoj jezgri procesora, u ovom radu će se opisati postupak prilagođenja
LTZVisora za obje jezgre ZedBoarda kako bi se maksimalno iskoristile mogućnosti platforme.

\chapter{Arhitektura Cortex-A9 procesora}
APU (engl. \textit{Application Processing Unit}) Zynq-7000 platforme može sadržavati jednu ili dvije jezgre, odnosno jedan
ili dva Cortex-A9 procesora \cite{zynq_trm}. ZedBoard sadrži dva Cortex-A9 procesora s koprocesorskom podrškom u višejezgrenoj
konfiguraciji i \textit{little-endian} arhitekturi. Dva CPU-a dijele \textit{cache} memoriju druge razine,
odnosno L2 \textit{cache} memoriju, od 512~kB.
Oba procesora su visokih performansi i niske potrošnje. Za razliku od L2 \textit{cache} memorije, L1 \textit{cache}
memorija nije dijeljena između procesora te svaki procesor implementira odvojenu podatkovnu i instrukcijsku
L1 \textit{cache} memoriju od 32~kB. Platforma ima potpunu podršku sustava virtualne memorije ARMv7 arhitekture kojoj
pripadaju procesori ZedBoard platforme. Procesori podržavaju 32-bitne ARM i Thumb instrukcijske setove te 16-bitne
Thumb instrukcije i 8-bitne Java bajt kodove. Prisutna je i SCU (engl. \textit{Snoop Control Unit}) koja je nužna za održavanje
koherencije između L1 \textit{cache} memorije između dva procesora. Komunikacija između PL-a i APU je ostvarena
pomoću ACP (engl. \textit{Accelerator Coherency Port}). Ispitivanje i kontrola procesora se odvija pomoću DAP-a
(engl. \textit{Debug Access Port}). Procesori podržavaju različite načine radova, uključujući \textit{supervisor},
sustavski (engl. \textit{system}) i korisnički (engl. \textit{user}) način rada što omogućava različite razine
zaštite na aplikacijskoj razini. \textit{TrustZone} ekstenzija procesora omogućava razvoj sigurnog okruženja za
izvođenje aplikacija i čuvanje njihovog sadržaja. Kako bi se minimizirao utjecaj strojnih ciklusa koji su potrebni
za izvođenje instrukcija grananja, Cortex-A9 implementira statičko i dinamičko predviđanje grananja (engl.
\textit{branch prediction}). Statičko predviđanje je određeno za vrijeme prevođenja koda, a dinamičko koristi
ishod izvođenja prošle instrukcije kako bi se odredilo hoće li se predviđeno grananje izvesti ili ne. Neka od
grananja koja se mogu predvidjeti su uvjetna i bezuvjetna grananja te se navedeno dinamičko grananje može isključiti.
Platforma sadrži i MMU (engl. \textit{Memory Management Unit}) jedinicu koja je prilagođena višeprocesorskim i sigurnosnim
ekstenzijama.

\section{Pokretanje i konfiguracija sustava}
Nakon postavljanja izvornih vrijednosti koje se odvija nakon dovođenja napajanja (engl. \textit{power
on reset}), hardver ispituje izvode platforme koji sadrže informaciju o tome na koji način će se pokrenuti sustav na
platformi. Moguće pokretanje sustava je s SD kartice, preko JTAG (engl. \textit{Joint Test Action Group}) modula
ili QSPI (engl. \textit{Quad Serial Peripheral Interface}) memorije. Nakon inicijalnog
čitanja izvoda, vrijednost se sprema u odgovarajući registar iz kojeg se čita na koji način se pokreće sustav sve do
nestanka napajanja platforme. Određivanjem načina pokretanja sustava započinje sam proces pokretanja, odnosno
počinje se izvoditi BootROM kod kojeg nije moguće mijenjati. Sveukupno pokretanje sustava se odvija u tri razine
koje su opisane tablicom~\ref{boot_stages}.

\begin{table}[H]
  \centering
  \caption{Razine pokretanja sustava Zynq-7000 platforme}
  \label{boot_stages}
  \begin{tabular}{|| p{2cm} | p{12cm} ||}
    \hline
    \textbf{Razina} & \textbf{Opis razine} \\
    \hline\hline
    Razina 0 & Odvija se odmah nakon postavljanja inicijalnih vrijednosti nakon dovedenog napajanja platformi.
    Radi se o BootROM kodu koji se izvodi na primarnom procesoru CPU0. BootROM kod izvodi traženje valjanog
    BootROM zaglavlja koji se nalazi u \textit{flash} memoriji uređaja s kojeg se pokreće sustav. Iz navedenog
    zaglavlja se određuje daljnji tok pokretanja sustava i prijelaz u Razinu 1. Nakon pokretanja hardvera, oba
    procesora izvode isti BootROM kod koji se nalazi na adresi 0x00000000 koji služi za određivanje vlastitog
    CPU identiteta. Daljnje izvođenje BootROM koda se izvodi na primarnom CPU0 procesoru, dok sekundarni CPU1
    počinje izvoditi WFE (engl. \textit{Wait For Event}) instrukciju.\\
    \hline
    Razina 1 & Odnosi se na prvostupanjski pokretač sustava ili FSBL (engl. \textit{First Stage Bootloader}) koji
    je zadužen za inicijaliziranje PS konfiguracije~\cite{zynq_swdg}. Uz inicijaliziranje, zadužen je i za konfiguriranje PL-a
    platforme s \textit{bitstream} datotekom, ako postoji. Sljedeći korak ove razine je učitavanje SSBL-a (engl.
    \textit{Second Stage Bootloader}) ili korisničke aplikacije, nakon čega slijedi i predavanje kontrole SSBL-u
    ili aplikaciji.\\
    \hline
    Razina 2 & Izvođenje korisničke aplikacije ili \textit{u-Boot} programa koji je sličan Linuxovoj ljusci te može
    poslužiti za učitavanje i pokretanje korisničke aplikacije.\\
    \hline
  \end{tabular}
\end{table}
Korisnička aplikacija mora sadržavati postupak CPU inicijalizacije, koji je sljedeći:
\begin{enumerate}
  \item{Upisati adresu tablice prekidnih vektora u odgovarajući registar}
  \item{Onesposobiti L1 \textit{cache} memoriju, TLB (\textit{translation look-aside buffers}) i predviđanje grananja}
  \item{Onesposobiti L2 \textit{cache} memoriju}
  \item{Pripremiti tablice stranica i učitati ih u fizičku memoriju}
  \item{Postaviti stog}
  \item{Učitati adresu tablice stranica u registar tablica za prevođenje}
  \item{Postaviti MMU bit u kontrolnom registru sustava}
  \item{Inicijalizirati i omogućiti L2 \textit{cahce} memoriju}
  \item{Omogućiti L1 \textit{cache} memoriju u kontrolnom registru sustava}
  \item{Skočiti na početak korisničke aplikacije}
\end{enumerate}

\subsection{Sigurno pokretanje sustava}
Sigurno pokretanje sustava se odnosi na sposobnost uređaja da provede pokretanje sustava koje učitava autentičnu i
kriptiranu PS sliku sustava i PL \textit{bitstream}. BootROM jedini može inicirati sigurno pokretanje sustava.
Ako je RSA-PSS (\textit{Rivest, Sharim and Adleman~-~Probabilistic Signature Scheme}) autentifikacija  omogućena,
BootROM će koristiti javni ključ PuK (\textit{Public Key}) za autentifikaciju FSBL-a. Omogućavanje sigurnog
pokretanja sustava se može izvesti modificiranjem BootROM zaglavlja u kojem se mora postaviti identifikator sigurnog
pokretanja sustava. Ako je sigurno pokretanje sustava omogućeno, BootROM automatski omogućuje AES (\textit{Advanced
Encryption Standard}) i HMAC (\textit{Key-hash message authentication code}) jedinice u PL-u. Kriptiranog FSBL-a, BootROM
šalje u AES i HMAC te se dekriptirani FSBL vraća u PS i kopira u \textit{on-chip} RAM (OCM). Nakon toga, PS može sigurno
dizajnirati PL slanjem kriptiranog PL \textit{bitstreama} u AES/HMAC jedinice nakon čega se dekriptirani
\textit{bitstream} primjenjuje na PL.
Prilikom pokretanja sustava s SD kartice, ako autentifikacija FSBL-a ne prođe, uređaj ide u sigurnosno zaključavanje
ili u stanje greške. Kako je sigurno pokretanje sustava izvedeno u PL-u, BootROM mora pričekati da se PL-u dovede napajanje
prija slanja FSBL-a u PL. Nakon što se FSBL uspješno autentificira, FSBL kreće s izvođenjem. Ako je FSBL kriptiran,
preporučuje se da se i ostali podaci kriptiraju. Slike za pokretanje sustava se kriptiraju pomoću Bootgen alata kojeg nudi
Xilinxov SDK (engl. \textit{Software Development Kit}) koji traži upis ključa kriptiranja i autentični potpis (HMAC ključ i
potpis).
\section{Prekidni sustav}
Svaki CPU platforme ima set privatnih periferijskih prekida, PPI (engl. \textit{private peripheral interrupts}),
za koje svaki procesor ima mogućnost privatnog pristupa registrima. Oba procesora platforme imaju svoju kopiju privatnih
registara.
Takvoj vrsti prekida pripadaju globalno brojilo, privatno \textit{watchdog} brojilo, privatno brojilo i FIQ (engl.
\textit{Fast Interrupt Request}) i IRQ (engl. \textit{Interrupt Request}) koji dolaze s programabilne logike.
Kao i PPI, procesori također imaju mogućnost generiranja softverski generiranih prekida, SGI (engl. \textit{Software
Generated Interrupt}), s vlastitim kopijama registara za podešavanje SGI prekida. U sustavu postoje i periferijski prekidi
koji su dijeljeni između procesora~-~SPI (engl. \textit{Shared Peripheral Interrupt}) koji, ovisno o konfiguraciji,
mogu biti dostupni jednom ili oba procesora. Glavni upravitelj prekidima u sustavu je GIC (engl. \textit{Generic
Interrupt Controller}) koji prekide prosljeđuje odabranom CPU-u. Svi prekidi imaju svoj konfigurabilni prioritet
i listu CPU-a koji mogu obraditi prekid.

\subsection{GIC (engl. \textit{Generic Interrupt Controller})}
GIC je resurs platforme koji služi za konfiguriranje i upravljanje prekidima u sustavu s jednim ili više procesora
\cite{gic}.
Uključuje registre za upravljanje izvorima prekida, ponašanje prekida i povezivanje prekida s jednim ili više
procesora. Uz implementaciju sigurnosnih ekstenzija GIC-a, uvodi se funkcionalnost grupiranja prekida koja omogućuje:
\begin{itemize}
  \item{konfiguriranje svakog prekida kao Grupa~0 ili Grupa~1}
  \item{signaliziranje prekida Grupe~0 ciljanom procesoru pomoću IRQ ili FIQ}
  \item{signaliziranje prekida Grupe~1 ciljanom procesoru samo pomoću IRQ}
  \item{jedinstvenu obradu prioriteta prekida Grupe~0 i Grupe~1}
  \item{izborno zaključavanje konfiguriranja nekih prekida Grupe~0}
\end{itemize}
Kod višeprocesorskih sustava, GIC implementira dva modela obrade prekida u slučaju da je prekid namijenjen više
ili svim procesorima u sustavu. Prvi model je 1-N, gdje N procesora mogu obraditi prekid, ali se GIC pobrine da samo
jedan procesor u sustavu obradi prekid. Ostali procesori u sustavu prime nepredvidljivi (engl. \textit{spurious}) prekid.
Drugi model je N-N, gdje jedan procesor obrađuje prekid, a ostalima je prikazano stanje čekanja na obradu prekida.
Kod takvog modela se koriste određeni protokoli kako bi prekid bio obrađen jednom. U sklopu GIC-a postoji više kopija
prekida u sustavu, odnosno postoji više prekida s istim prekidnim brojem, za svaki procesor u sustavu postoji jedan prekidni
broj. GIC se može podijeliti na dvije logičke cjeline:
\begin{itemize}
  \item{jedan blok distributera}
  \item{jedan ili više blokova CPU sučelja}
\end{itemize}
Obrada prekida se odvija sljedećim redosljedom:
\begin{enumerate}
  \item{GIC određuje prekide koji su omogućeni}
  \item{GIC određuje ciljani procesor ili procesore za sve prekide koji čekaju na obradu}
  \item{Distributer prosljeđuje prekid najvišeg prioriteta odgovarajućem CPU sučelju}
  \item{CPU sučelje odlučuje je li potrebno generirati zahtjev za obradu prekida procesora i ako treba, generirati ga}
  \item{Procesor priznaje prekid, na što GIC vraća ID prekida}
  \item{Nakon obrade, procesor signalizira kraj prekida GIC-u}
\end{enumerate}

\subsubsection{Distributer}
Distributer je dio GIC-a koji prikuplja sve izvore prekida te određuje prioritet svakog prekida. Za svako CPU sučelje u
sustavu prosljeđuje prekid najvišeg prioriteta. Distributer pruža sljedeće mogućnosti:
\begin{itemize}
  \item{globalno dozvoljavanje prosljeđivanja prekida CPU sučeljima}
  \item{omogućavanje i onemogućavanje svakog prekida}
  \item{postavljanje prioriteta svakog prekida}
  \item{postavljanje liste ciljanih procesora za svaki prekid}
  \item{postavljanje osjetljivosti svakog prekida:}
  \begin{enumerate}
    \item{osjetljivost na razinu}
    \item{osjetljivost na brid}
  \end{enumerate}
  \item{konfiguriranje prekida kao Grupa~0 ili Grupa~1}
  \item{prosljeđivanje SGI-a jednom ili više procesora}
\end{itemize}
Vidljivost stanja svakog prekida (neaktivan, aktivan, čeka na obradu) je omogućena čitanjem odgovarajućih registara.
Distributer sadrži i registre za postavljanje i brisanje stanja za čekanje na obradu perifernih prekida. Prekidi koji
su duplicirani za svaki procesor se odnose na prekide s prekidnim brojevima od 0 do 31, od kojih su od 0 do 15 SGI, a
od 16 do 31 PPI. Takvi prekidi se identificiraju pomoću prekidnog broja i procesora kojem su namijenjeni. Dupliciranje
prekida znači da distributer može istovremeno upravljati s više izvora prekida bez konflikta resursa.

\subsubsection{CPU sučelje}
CPU sučelje predstavlja sučelje za procesor koji je povezan s GIC-om. Njegova funkcija je prosljeđivanje prekida najvišeg
prioriteta procesoru, uz obzir na maskirane prekide i postavke istiskivanja prekida. CPU sučelje sadrži registar koji
služi za signaliziranje prihvaćanja prekida. Prihvaćanje prekida se izvodi čitanjem iz IAR-a (engl. \textit{Interrupt
Acknowledge Register}). Mogućnosti CPU sučelja su sljedeće:
\begin{itemize}
  \item{omogućavanje signaliziranja prekida procesoru}
  \item{potvrde prekida}
  \item{označavanje kraja obrade prekida}
  \item{postavljanje maskiranja prekidnog prioriteta}
  \item{definiranje postupka istiskivanja za procesor}
  \item{određivanje najvišeg prioriteta prekida koji čeka na obradu}
\end{itemize}

\section{Koprocesorska podrška}
ARM implementira koprocesorsku podršku koja proširuje funkcionalnosti ARM procesora. Sveukupno je implementirano 16 koprocesora:
CP0~-~CP15 \cite{arch_man}. Posebne namjene koprocesora su:
\begin{itemize}
  \item{CP15: ima funkcionalnost kontrole nad sustavom, služi za identifikaciju arhitekture i mogućnosti platforme. Drži
  kontrolu, status informacija i konfiguraciju sustava}
  \item{CP14: sadrži sustav za ispitivanje, kontrolu nad Thumb okruženjem izvođenja koda i konfiguraciju izvršavanja Java
  bajt kodova}
  \item{CP10 i CP11: zajedno podržavaju \textit{floating-point} operacije i operacije s vektorima}
  \item{CP8, CP9, CP12 i CP13: rezervirani}
  \item{CP0~-~CP7: sadrže informacije specifične za proizvođače}
\end{itemize}
Svi registri su duljine 32 bita. Pristup koprocesorskim registrima se izvodi pomoću MCR i MRC instrukcija, gdje je MCR
instrukcija za pisanje u koprocesorski registar, a MRC instrukcija za čitanje iz koprocesorskog registra.
Prilikom pristupa koprocesorskim registrima, potrebno je specificirati:
\begin{itemize}
  \item{identifikator koprocesora}
  \item{dva koprocesorska registra CRn i CRm, gdje je CRn primarni registar}
  \item{dva koprocesorska operacijska koda}
  \item{ARM-ov registar opće namjene čiji će se sadržaj kopirati u koprocesorski registar ili u koji će biti pohranjen
  sadržaj koprocesorskog registra}
\end{itemize}

\section{MMU (engl. \textit{Memory Management Unit})}
MMU jedinica pruža zaštitu memorije i adresna prevođenja. Stranice za tablice za prevođenje mogu imati veličine od 4~kB,
64~kB, 1~MB i 16~MB i 16 pristupnih domena (skup memorijskih regija). MMU ZedBoard platforme je prilagođena sigurnosnim
ekstenzijama i višeprocesorskim konfiguracijama. Kontrolira setove adresnih mapa za prevođenje virtualne memorije u fizičku.
Atributi memorije sadržani su u instrukcijskim i podatkovnim spremnicima za prevođenje TLB (\textit{translation look-aside
buffers}). Glavna funkcija MMU jedinice je adresno prevođenje koje služi za prevođenje adresa koda i podataka iz virtualnih u
fizičke. Omogućava dodjelu memorije zadacima na način da zadaci nemaju znanja o postojanju drugih zadataka u sustavu. Takvo
memorijsko konfiguriranje omogućuje jednostavniju implementaciju aplikacija obzirom da sve aplikacije/zadaci koriste jednak
virtualni memorijski prostor. MMU sadrži dvije glavne komponente ključne za ostvarenje adresnih prevođenja:
\begin{itemize}
  \item{pretraživač tablica koji automatski dohvaća točan ulaz tablice za prevođenje za zahtjevano prevođenje}
  \item{spremnici za prevođenje koji pohranjuju nedavno korištene ulaze za prevođenje i ponašaju se slično kao \textit{cache}
  memorija za tablice za prevođenje}
\end{itemize}
Svaka virtualna adresa odgovara točno jednom ulazu u tablicu za prevođenje. Tablice za prevođenje, uz ulaze virtualne memorije,
sadrže i dozvole pristupa i atribute memorije za odgovarajuće stranice.

\chapter{Višejezgrene konfiguracije Zynq-7000 platforme}
Kao što je već rečeno, ZedBoard implementira Cortex-A9 procesor s dvije jezgre te je za navedenu
platformu moguće razviti aplikacije s različitim konfiguracijama obzirom na broj jezgri koje su potrebne
u sustavu. Moguće je implementirati:
\begin{itemize}
  \item{aplikaciju namijenjenu jednoj jezgri procesora (CPU0),}
  \item{dvije aplikacije, svaka namijenjena jednoj jezgri i}
  \item{aplikaciju namijenjena objema jezgrama u sustavu.}
\end{itemize}
Korištenjem prednosti višejezgrenih konfiguracija, dobiju se bolje performanse platforme u smislu da je višejezgrena platforma
sposobna obavljati N zadataka u nekom vremenskom trenutku, gde je N broj jezgri platforme \cite{cortexa_pg}. Zbog paralelnosti
obavljanja zadataka, određeni posao se može obaviti brže nego na platformi s jednom jezgrom. Nakon što obave potrebni posao,
jezgre mogu ići u stanje gašenja kako bi se smanjila potrošnja. Još jedan način smanjenja potrošnje je da se smanji frekvencija
na kojoj rade jezgre. Uz to, višejezgrene platforme mogu imati bolji odziv u odnosu na platforme s jednom jezgrom jer bilo koja
jezgra može obraditi prekid, što smanjuje broj prekida koje je potrebno obraditi na jednoj jezgri.\\
Važno je napomenuti da je jedna jezgra sustava (CPU0) primarna, a druga (CPU1) sekundarna. Prilikom
pokretanja sustava, na platformi je aktivna samo primarna jezgra, dok se sekundarna jezgra nalazi u
WFE (engl. \textit{Wait For Event}) stanju. Nakon što se sustav pokrenuo, primarna jezgra je zadužena
za buđenje sekundarne jezgre. Sekundarnu jezgru je moguće probuditi generiranjem događaja sustava
(engl. \textit{system event}), nakon čega sekundarna jezgra automatski skače na adresu koja je upisana
na lokaciji 0xFFFFFFF0. Jedan od načina na koji se može probuditi sekundarna jezgra je da aplikacija
koja se izvršava na CPU0 upiše adresu na kojoj se nalazi aplikacija za CPU1 na memorijsku lokaciju
0xFFFFFFF0 te izvrši SEV (engl. \textit{send event}) instrukciju koja rezultira buđenjem CPU1.
Komunikaciju između dvije jezgre je moguće ostvariti pomoću prekida između procesora
(\textit{inter-processor interrupt}), dijeljene memorije ili razmijene poruka. Prekidi između procesora
na ovoj platformi se implementiraju pomoću softverski generiranih prekida (SGI). Za bolje razumijevanje
višejezgrenih konfiguracija, u nastavku su dani jednostavni primjeri razvoja aplikacije za dvije različite
konfiguracije. Obje aplikacije su razvijene pomoću lanca alata arm-none-eabi i Xilinx SDK 2019 (engl.
\textit{Software Development Kit}) uz zadanu konfiguraciju hardvera (bez potrebe za generiranjem
novog dizajna hardvera). Za potrebe generiranja datoteke za pokretanje sustava korišten je već gotov FSBL projekt
kojeg nudi XSDK koji ima mogućnost učitavanja više izvornih datoteka odjednom. Datoteka za pokretanje sustava je
generirana pomoću alata Bootgen kojeg nudi XSDK.

\section{Asimetrično višejezgreno procesiranje}
Asimetrično višejezgreno procesiranje ili AMP (engl. \textit{Asymmetric Multiprocessing}) se odnosi na
konfiguraciju u kojoj svaki procesor (jezgra) izvršava svoju aplikaciju, odnosno gdje svaki procesor ima
svoju sliku operacijskog sustava. Dakle, kako bi bilo moguće razviti obje aplikacije, potrebno je koristiti
odvojene skripte za memorijsko povezivanje (\textit{linker} skripte) i skripte za pokretanje sustava. Oba
operacijska sustava dijele isti fizički memorijski prostor, odnosno ne postoji nikakva izolacija između dva
operacijska sustava. Karakteristike AMP konfiguracije su sljedeće:
\begin{itemize}
  \item{većina uređaja mora biti posvećena određenom procesoru}
  \item{upravitelj prekidima je dijeljen između procesora}
  \item{samo jedan procesor je zadužen za inicijalizaciju upravitelja prekidima}
\end{itemize}
FSBL je zadužen za učitavanje obje aplikacije u memoriju. Opisana konfiguracija je prikazana slikom \ref{amp}.

\begin{figure}[H]
  \centering
	\includegraphics[width=300pt]{AMP.png}%
	\caption{AMP konfiguracija}
	\label{amp}%
\end{figure}

\subsection{Razvoj AMP aplikacije}
Kod razvoja AMP aplikacije u XSDK, nužno je stvoriti dva projekta, jedan za procesor CPU0 i drugi za CPU1.
Prilikom stvaranja projekta potrebno je odabrati za koji procesor je aplikacija namijenjena. Kod konfiguriranja
projekta za CPU1, prevoditelju projekta je potrebno dodati poseban indikator: \textit{USE\_AMP=1} kako bi aplikacija mogla
funkcionirati na ispravan način. Postavljanjem \textit{USE\_AMP} zastavice, otklanja se mogućnost rekonfiguriranja L2 \textit{cache}
memorije i distributera GIC upravitelja što se smatra nepoželjnim rukovanjem navedenih resursa koji su zajednički procesorima
u sustavu. Primjer nepoželjnog ponašanja zbog ne postavljanja navedene zastavice je dvostruka inicijalizacija distributera
GIC-a što bi moglo rezultirati gubitkom postavki prekida koje su postavljene primarnim procesorom. Takvo ponašanje bi
prekršilo jedno svojstvo AMP aplikacija koje se odnosi na to da je samo jedan procesor zadužen za inicijalizaciju upravitelja
prekidima, u ovom slučaju GIC distributera. CPU sučelje GIC-a se normalno inicijalizira na oba procesora, bez ograničenja.
Obzirom da su za razvoj AMP aplikacije potrebna dva projekta, potrebne su i dvije skripte za memorijsko povezivanje što
znači da svaki procesor mora imati svoje upravljačke programe za uređaje (\textit{device drivers}) koje treba koristiti.
Ako se za primjer uzme funkcija \textit{print}, koja se koristi za ispis preko serije korištenjem UART-a (engl. \textit{Universal
Asynchronous Receiver Transmitter}), implementirana procesorom CPU0, jasno je da CPU1 neće moći pozvati tu istu funkciju
jer funkcija nije vidljiva u memorijskom prostoru CPU1 aplikacije. Da bi CPU1 mogao koristiti istu \textit{print} funkciju,
CPU1 treba implementirati funkcionalnost te funkcije kako bi skripta za memorijsko povezivanje mogla locirati navedenu
funkciju. Iz ovog se vidi da nije praktično koristiti isti uređaj na oba procesora te se zbog toga većina uređaja dodjeljuje
određenom procesoru. Iako se UART može dijeliti između procesora, neke periferije, kao što su to brojila, se ne mogu.
Za razliku od CPU0, CPU1 mora eksplicitno omogućiti prekide u kontrolnom registru procesora CPSR. Prekidi za CPU0 su
automatski omogućeni FSBL-om. Podrazumijeva se da CPU0 aplikacija mora sadržavati dio koda koji služi za buđenje CPU1
čime započinje pokretanje sustava na CPU1. Isto tako, podrazumijeva se i da se adresa od koje kreće CPU1 aplikacija
ispravno podesi u skripti za memorijsko povezivanje CPU1 aplikacije. Nakon što su željene aplikacije razvijene, moguće
je kreirati datoteku za pokretanje sustava BOOT.bin. Programski tok od pokretanja sustava (Razine~1) prikazana je slikom
\ref{amp_app}.

\begin{figure}[H]
  \centering
	\includegraphics[width=300pt]{AMP_app.png}%
	\caption{AMP aplikacija}
	\label{amp_app}%
\end{figure}

\section{Simetrično višejezgreno procesiranje}
Simetrično višejezgreno procesiranje ili SMP (engl. \textit{Symmetric Multiprocessing}) se odnosi na
konfiguraciju u kojoj su oba procesora ZedBoard platforme zadužena za jedan operacijski sustav, odnosno
za jednu aplikaciju. Kod razvoja SMP aplikacije potrebna je samo jedna skripta za memorijsko povezivanje, ali
dvije skripte za pokretanje sustava. U slučaju razvoja aplikacije operacijskog sustava, u sustavu postoji
samo jedan raspoređivač zadataka koji je zadužen za raspoređivanje procesa, odnosno zadataka, na obje jezgre.
Prilikom razvoja SMP aplikacije moguće je:
\begin{itemize}
  \item{odrediti procesor koji će izvoditi određeni proces,}
  \item{obraditi prekid s bilo kojim slobodnim procesorom,}
  \item{odrediti jedan procesor koji će biti zadužen za inicijalizaciju i pokretanje drugih procesora.}
\end{itemize}
SMP ima mogućnost dinamičkog određivanja uloge svakog procesora te se svaki zadatak može izvoditi na bilo kojoj jezgri.
Opisana konfiguracija prikazana je slikom \ref{smp}.
\begin{figure}[H]
  \centering
	\includegraphics[width=300pt]{SMP.png}%
	\caption{SMP konfiguracija}
	\label{smp}%
\end{figure}

\subsection{Razvoj SMP aplikacije}
Prilikom razvoja SMP aplikacije u XSDK, potrebno je stvoriti jedan projekt koji je namijenjen primarnom procesoru, CPU0.
Pošto se sustav CPU0 procesora pokreće prvi, CPU0 je zadužen za inicijalizaciju i pokretanje sustava na CPU1. Iz navedenog
se vidi da se u projekt treba dodati skripta za pokretanje sustava na CPU1. Za te potrebe, duplicirala se je boot.S skripta
koju nudi Xilinxova biblioteka. Kako razvoj SMP aplikacije ne zahtjeva posebni projekt za CPU1, potrebno je modificirati
skriptu za pokretanje sustava na CPU1 na način da se izbaci dio s inicijalizacijom L2 \textit{cache} memorije (kod AMP
aplikacije, to je ostvareno pomoću indikatora \textit{USE\_AMP}). Također, potrebno je promijeniti aplikaciju na koju se skače
nakon inicijalizacije CPU1 procesora (postaviti skok na željenu CPU1 aplikaciju u skripti za pokretanje sustava).
Poznato je da svaki procesor ima svoju tablicu
prekidnih vektora te je iz tog razloga potrebno dodati asemblerski kod koji će sadržavati potrebnu tablicu prekidnih vektora.
Tablica prekidnih vektora mora biti sadržana u memoriji koja ima odmak 0x00 od početne adrese na kojoj se nalazi
aplikacija CPU1 procesora. Da bi se ostvario potrebni odmak, poduzeti su sljedeći koraci:
\begin{enumerate}
  \item{U skriptu za memorijsko povezivanje, dodana je adresa na kojoj će se nalaziti CPU1 aplikacija}
  \item{U skriptu za memorijsko povezivanje, dodana je nova sekcija koje će sadržavati sav CPU1 kod (ili minimalno asemblerski
  kod tablice prekidnih vektora CPU1)}
  \item{U asemblerski kod tablice prekidnih vektora CPU1, dodana je direktiva .org 0 koja osigurava da se kod smjesti na
  početak odabrane sekcije (odmak 0x00 od početka memorijskog segmenta sekcije)}
\end{enumerate}
Važno je napomenuti i da CPU1 treba imati poseban stog namijenjen CPU1 procesoru te je stog potrebno dodati u skriptu za
memorijsko povezivanje. Uz to, u skriptu za pokretanje je potrebno navesti odgovarajući stog CPU1 procesora.
Nakon navedenih promjena, projekt je spreman za implementaciju aplikacije. Pošto se radi o SMP konfiguraciji, razvija se
samo jedna aplikacija koja sadrži dva zadatka koji se konkurentno izvode (jedan na CPU0, a drugi na CPU1). Također, sve
funkcije dostupne jednom procesoru su dostupne i drugom procesoru jer dijele jedan memorijski prostor (jedna skripta za
memorijsko povezivanje). Jedna ključna stavka kod razvoja SMP aplikacije je da ako oba procesora u aplikaciji pristupaju
istom resursu, za ispravno funkcioniranje je potrebno implementirati sinkronizacijski mehanizam. Sinkronizacijski mehanizam
osigurava da jednom resursu ne pristupaju oba procesora u istom trenutku. Primjer jednostavnog sinkronizacijskog mehanizma
iskorištenog u razvoju SMP aplikacije je korištenje jedne memorijske lokacije koja služi za indikaciju je li resurs slobodan.
Kao i kod AMP aplikacije, mora se pobrinuti za to da GIC distributer bude inicijaliziran samo jednom. Isto tako je potrebno
omogućiti prekide u CPSR registru CPU1 procesora u slučaju da će se prekidi obrađivati procesorom CPU1. Nakon što CPU0
probudi CPU1, CPU1 počinje izvoditi dio koda koji je smješten na početku sekcije koja je rezervirana za CPU1 kod.
Podrazumijeva se da se na odgovarajuću memorijsku lokaciju, koja sadrži informaciju o adresi na koju skače CPU1 nakon buđenja,
upiše adresa koja je jednaka početnoj adresi CPU1 sekcije. Tok programa od pokretanja sustava (Razine~1) prikazan je slikom
\ref{smp_app}.
\begin{figure}[H]
  \centering
	\includegraphics[width=300pt]{SMP_app.png}%
	\caption{SMP aplikacija}
	\label{smp_app}%
\end{figure}

\chapter{\textit{TrustZone} sigurnosna ekstenzija Cortex-A platforma}
Potreba za sigurnošću ugradbenih računala sve više raste zbog rastuće vrijednosti podataka pohranjenih na njima kao
što su to bankovni računi ili sinkronizirane \textit{e-mail} adrese \cite{tz_wp}. Povećanjem vrijednosti podataka pohranjenih na
uređaje povećava vjerojatnost napada na uređaj. Cilj \textit{TrustZone} ekstenzije je pružiti robusno sigurnosno okruženje
uređajima bogatih operacijskih mogućnosti integrirajući zaštitne mjere u ARM-ov procesor, sabirnički sustav i periferalni
sustav. Kako bi se odredile mjere zaštite, potrebno je odrediti napade od kojih se želi zaštititi, odnosno koji resursi
moraju biti zaštićeni.

\section{Potreba za sigurnosti u mobilnom sektoru}
Dvije kritične komponente mobilnih uređaja su IMEI (engl. \textit{International Mobile Equipment Identity}) kod i
\textit{SIMLock}. IMEI je jedinstveni kod koji se koristi za identifikaciju uređaja kad se priključi na mrežu te se prilikom
krađe uređaja koristi za zabranu pristupa mreži. \textit{SIMLock} je protokol koji se koristi za povezivanje uređaja i
SIM kartice određenog operatera te se kod krađe uređaja koristi za vezanje uređaja i operatera do isteka ugovora. Ovakvi
zaštitni mehanizmi se mogu lako premostiti (obično reprogramabilnim alatom i USB kablom). O tome koliko je jednostavno
srušiti takve sigurnosne mehanizme, govori statistika Ujedinjenog Kraljevstva koja iznosi da se pola od ukupnih uličnih
zločina odvija preko krađe mobilnih uređaja što donosi velike novčane štete industriji. Noviji uređaji imaju dodatne
zaštitne mehanizme koji se odnose na sadržaj i servise koji su dostupni lokalno na uređaju. Kritične značajke novih
uređaja su sinkronizirane \textit{e-mail} adrese, povećane mogućnosti žične i bežične povezanosti i velike količine
podatkovne memorije. Primjer industrije koja nije otvorenog sustava je automobilska industrija koja također snosi velike
novčane štete zbog napada na ugradbena računala. Sigurnosne značajke potrebne kod takvih ugradbenih sustava su autentičnost
nadogradnje ugrađenog softvera i osiguranje da se ispitivanje sustava ne može zlonamjerno iskoristiti.
Takve značajke se mogu implementirati pomoću \textit{TrustZone} ekstenzije. Prilikom dizajna sigurnosnog rješenja, proizvođač
mora izmjeriti omjer cijena koje moraju uložiti u dizajn i štete koju bi mogli imati zbog napada. Zbog niže kompleksnosti
izvedbe \textit{TrustZone} ekstenzije, ARM ima i niže troškove proizvodnje ekstenzije što ide u prilog proizvođačima
uređaja.

\section{Softverska virtualizacija}
Virtualizacija je jedan od načina kako ostvariti sigurnosni mehanizam u kojem se visoko pouzdani sloj za upravljanje,
odnosno monitor virtualnih strojeva, izvodi u privilegiranom načinu rada procesora. Monitor virtualnih strojeva razdvaja
više neovisnih softverskih okruženja, koja se izvode povrh monitora, koristeći MMU. Svako softversko okruženje je
smješteno u virtualni stroj kojim upravlja monitor virtualnih strojeva. Virtualni strojevi su sigurni od međusobnih softverskih
napada virtualnih strojeva upravo zato što njima upravlja monitor virtualnih strojeva. Ovakav opis virtualizacije pripada
paravirtualizaciji koja je specifična za ugradbena računala. Za implementaciju monitora virtualnih strojeva, minimalan
hardverski uvjet je prisutnost MMU jedinice što predstavlja prednost ovako ostvarenog sigurnosnog mehanizma. Sigurnosno
osjetljive aplikacije mogu biti smještene u sigurnosno okruženje unutar monitora virtualnih strojeva. Nadalje, monitor
virtualnih strojeva omogućuje mehanizam komunikacije između virtualnih strojeva. Iako se softverska virtualizacija čini kao
čvrst oblik sigurnosnog mehanizma, ipak postoji skup sigurnosnih značajki koje ne zadovoljavaju sigurnosne uvjete. Primjer
jedne od njih je da virtualizacija osigurava izolaciju samo na razini procesora. Ako se u sustavu želi zaštititi DMA (engl.
\textit{Direct Memory Access}) jedinica, koja ostaje nezaštićena, potrebno je omogućiti mehanizam upravljanja DMA jedinicom
u softverskom sloju monitora virtualnih strojeva što znatno usporava cijeli sustav. Isto tako, virtualizacija ne nudi nikakvu
hardversku zaštitu te sustav može biti lako ranjiv kroz sustav za ispitivanje (JTAG).

\section{\textit{TrustZone} arhitektura}
Općeniti problem sigurnosnih mehanizama je da štite samo određene resurse. Kao primjer se mogu uzeti kriptografički blokovi
platforme koji se koriste za zaštitu ključeva. Takvi blokovi gube svoju glavnu funkciju ako nisu zaštićeni i dekriptirani
podaci izvan kriptografičkih blokova. Ideja \textit{TrustZone} ekstenzije je dati mogućnost zaštite cjelokupnog hardverskog
prostora. Ekstenzija pruža konfigurabilni sustav kojeg dizajner može konfigurirati na način koji je specifičan za željenu
aplikaciju. AMBA3 AXI sabirnički protokol omogućava \textit{TrustZoneov} koncept dva svijeta: Sigurnog (\textit{Secure}) i
Nesigurnog ili Normalnog (\textit{Non-Secure}) svijeta. Smještanje osjetljivih resursa u Sigurni svijet štiti uređaj i od napada
od kojih se je teško obraniti, kao što je to unošenje lozinke putem tipkovnice ili dodirnog zaslona.
Kako bi takva konfiguracija bila moguća, \textit{TrustZone} sadrži tri ključne komponente:
\begin{itemize}
  \item{TZPC (\textit{TrustZone Protection Controller}) - omogućava dinamičku izmjenu sigurnosnog stanja prilikom izvođenja
  programa}
  \item{TZASC (\textit{TrustZone Address Space Controller}) - omogućava podjelu memorije na Sigurne i Nesigurne segmente}
  \item{TZMA (\textit{TrustZone Memory Adapter}) - omogućava označavanje segmenata statičke memorije kao Sigurna memorija}
\end{itemize}
Ekstenzija samog procesora
omogućava efektivno izvođenje koda Normalnog i Sigurnog svijeta pomoću metode vremenskog dijeljenja (\textit{time-sliced
fashion}). Ključna mogućnost ekstenzije je kontroliranje pristupa ispitivanja Sigurnog softvera. Promjena uvedena u AMBA3
AXI sabirnicu je dodavanje 33. NS (\textit{Non-Secure}) bita prilikom čitanja i pisanja. Dodatni bit indicira s kojeg
svijeta dolazi zahtjev za razmjenu podataka te onemogućava pristup Nesigurnog svijeta Sigurnom. Sigurnost periferija je
izvedena pomoću AXI-APB mosta, gdje je APB (engl. \textit{Advanced Peripheral Bus}) sabirnica na koju su spojene
periferije. APB ne implementira dodatni bit kao AXI sabirnice te je stoga AXI-APB most zadužen za provjeru valjanosti
zahtjeva. Takvo svojstvo omogućuje osiguravanje tipkovnice za potrebe unosa lozinke. Ekstenzija procesora uvodi dvije virtualne
jezgre za svaki procesor, gdje je jedna virtualna jezgra zadužena za Sigurni, a druga za Nesigurni svijet kako je prikazano na
slici \ref{vcpu}. Na slici, oznaka VCPU označuje virtualni CPU.
\begin{figure}[H]
  \centering
	\includegraphics[width=200pt]{vcpu2.png}%
	\caption{Virtualizacija fizičkog procesora}
	\label{vcpu}%
\end{figure}
Uz promjenu na
sabirnici, \textit{TrustZone} uvodi i novi način rada procesora: nadgledni (\textit{monitor mode}) uz dva stanja: Sigurno
i Nesigurno stanje. Nadgledni način rada je uvijek u Sigurnom stanju.\\
Koncept dva svijeta se može gledati kao dva zadatka u operacijskom sustavu, gdje je softver koji se izvodi
u nadglednom načinu rada zadužen za zamjenu konteksta između dvije virtualne jezgre. Pokretanje cjelokupnog sustava s dva
svijeta prikazano je slikom~\ref{tz_boot}.
\begin{figure}[H]
  \centering
	\includegraphics[width=350pt]{tz_boot.png}%
	\caption{Pokretanje \textit{TrustZone} sustava}
	\label{tz_boot}%
\end{figure}
Sigurno pokretanje sustava dodaje kriptografičke provjere za svaku razinu pokretanja Sigurnog svijeta.
Prijelazi iz Nesigurnog stanja u nadgledni
način rada se izvode pomoću SMC (engl. \textit{Secure Monitor Call}) instrukcije ili konfiguracijom IRQ kao okidač za ulaz
u nadgledni način rada. Identifikacija svijeta u kojem se softver izvodi se nalazi u NS bitu SCR (\textit{Secure
Configuration Register}) registra CP15 koprocesora. Samo Sigurni softver može upravljati NS bitom SCR registra. Postavljanjem
NS bita u jedinicu se okida zamjena konteksta iz Sigurnog svijeta u Nesigurni svijet. \textit{TrustZone} predstavlja i
virtualnu MMU jedinicu, gdje je jedna virtualna MMU jedinica zadužena za jedan virtualni procesor. Opisnik tablice za prevođenje
sadrži NS polje koje dozvoljava Sigurnom softveru pristupanje Sigurnoj i Nesigurnoj tablici, a onemogućava pristup Sigurnoj
tablici od strane Nesigurnog softvera. Uz MMU, L1 \textit{cache} memorija se također dijeli na Sigurnu i Nesigurnu.\\
Softver nadglednog načina rada je zadužen za prijelaz između Sigurnog i Nesigurnog stanja te osigurava spremanje konteksta
svijeta iz kojeg prelazi i točnog povratka konteksta svijeta u koji se vraća. Za jednostavnost implementacije, preporučuje
se isključivanje prekida prilikom izvođenja nadglednog softvera. Sigurno stanje registara treba pospremiti u Sigurnu memoriju
gdje Nesigurni svijet ne može pristupiti Sigurnom kontekstu. Implementacija \textit{yield} funkcije se izvodi pomoću SMC
instrukcije koja može nositi i korisnu informaciju te u tom slučaju nadgledni način rada ne radi potpunu zamjenu konteksta.
Za smanjenje vremena zamjene konteksta, Sigurni softver može ograničiti Nesigurni pristup koprocesorskom sučelju te ako se
izabere takva konfiguracija, nadgledni način rada izvodi lijenu zamjenu konteksta.

\subsection{Utjecaj sigurnosnih ekstenzija na prekidni sustav}
GIC je svjestan sigurnosnih ekstenzija i daje mogućnost konfiguriranja Sigurnih i Nesigurnih prekida. Kod prekidnog sustava,
ARM preporučuje korištenje IRQ kao Nesigurne prekide, a FIQ kao Sigurne prekide što je konfigurabilno u GIC-ovim registrima.
Ako se koristi takav model, preporučeno je da se prilikom prijelaza u Nesigurni svijet SCR registar podesi tako da se izbriše
IRQ bit, a postavi FIQ bit. Kod prijelaza u Sigurni svijet preporučeno je podesiti SCR registar tako da se postavi IRQ bit, a
izbriše FIQ bit.
Sigurnosne ekstenzije omogućuju tri vrste tablica prekidnih vektora:
\begin{itemize}
  \item{za Sigurni svijet}
  \item{za Nesigurni svijet}
  \item{za nadgledni način rada}
\end{itemize}
Memorijsko mapiranje spomenutih tablica prekidnih vektora dano je tablicom \ref{vector_table}.
\begin{table}[H]
  \centering
  \caption{Tablice prekidnih vektora}
  \label{vector_table}
  \begin{tabular}{|| p{2cm} | p{4cm} | p{4cm} | p{4cm} ||}
    \hline
    \textbf{Memorijski odmak} & \textbf{Nesigurna tablica} & \textbf{Sigurna tablica} & \textbf{Nadgledna tablica} \\
    \hline\hline
    0x00 & Ne koristi se & \textit{Reset} & Ne koristi se\\
    \hline
    0x04 & Nedefinirana instrukcija & Nedefinirana instrukcija & Ne koristi se\\
    \hline
    0x08 & Poziv \textit{supervisoru} & Poziv \textit{supervisoru} & Sigurni poziv nadgledniku (SMC)\\
    \hline
    0x0C & \textit{Prefetch abort} & \textit{Prefetch abort} & \textit{Prefetch abort}\\
    \hline
    0x10 & \textit{Data abort} & \textit{Data abort} & \textit{Data abort}\\
    \hline
    0x14 & Ne koristi se & Ne koristi se & Ne koristi se\\
    \hline
    0x18 & IRQ & IRQ & IRQ\\
    \hline
    0x1C & FIQ & FIQ & FIQ\\
    \hline
  \end{tabular}
\end{table}
Bazna adresa Sigurne tablice prekidnih vektora može biti 0x0 ili 0xFFFF0000, dok se ostale adrese određuju softverski.
Nesigurni prekidi nemaju mogućnost konfiguriranja Sigurnih prekida te je opredjeljenje prekida kao Sigurni ili Nesigurni
moguće samo u Sigurnom softveru. Sigurni softver može osigurati da su svi Sigurni prekidi većeg prioriteta od Nesigurnih.
To je moguće jer prioritetni registar prekida u Sigurnom stanju ima implementirano 5 bitova, dok u Nesigurnom stanju ima
implementirano 4~bita.
Prekid Grupe 0 GIC-a se označava kao Sigurni prekid, a prekid Grupe 1 kao Nesigurni prekid. Pristup GIC-ovim registrima uz
sigurnosne ekstenzije imaju sljedeće značajke:
\begin{itemize}
  \item{Nesigurno čitanje polja registra koje sadrži informaciju o Sigurnom prekidu vraća 0}
  \item{GIC ignorira svako Nesigurno pisanje u polje registra koje drži informaciju o Sigurnom prekidu}
  \item{Sigurni softver posebno određuje koji prekidi će se koristiti kao Sigurni, a koji kao Nesigurni}
  \item{Nesigurni prekid signalizira IRQ zahtjev ciljanom procesoru}
  \item{Sigurni softver signalizira IRQ ili FIQ zahtjev ciljanom CPU-u}
  \item{Sigurni softver može upravljati prekidnim izvorima bez interferencije Nesigurnog softvera}
  \item{Sigurni softver se može koristiti i kao softver koji nije svjestan sigurnosnih ekstenzija}
\end{itemize}
ARM preporučuje korištenje prekida kao komunikaciju između procesora u sljedećoj konfiguraciji:
\begin{itemize}
  \item{Nesigurni prekidi: prekidi s prekidnim brojevima od 0-7}
  \item{Sigurni prekidi: prekidi s prekidnim brojevima od 8-15}
\end{itemize}

\subsection{Višejezgrene konfiguracije \textit{TrustZone} ekstenzije}
Jedan fizički procesor i njegova dva virtualna procesora čine jednu grupu procesora. Svaka grupa može biti konfigurirana za
korištenje u AMP ili SMP modelu. Kod SMP modela, korištenje L1 \textit{cache} memorije na oba procesora je koherentno što
je omogućeno SCU jedinicom. Prilikom razvoja AMP aplikacije, mora se ručno voditi briga o koherenciji (prazniti \textit{cache}
gdje je potrebno). Prijelaz između svjetova na jednom procesoru je neovisan o drugim procesorima. Za povećanje sigurnosti
prilikom implementacije Sigurnog softvera u višeprocesorskim sustavima, preporučuje se da Sigurni softver ne iskorištava
mogućnosti više procesora, iako Nesigurni softver možda i iskorištava. Razlog tome je kompleksnost implementacije što povlači
veću vjerojatnost pogreške, odnosno sustav postaje ranjiviji. Ako Sigurni softver ne koristi višeprocesorske mogućnosti,
a Nesigurni koristi potrebno je implementirati sinkronizaciju komunikacije između SMP Nesigurnog softvera i Sigurnog softvera.
Obzirom na SMP, moguće je ostvariti dva modela:
\begin{enumerate}
  \item{Sigurni softver implementiran na jednom procesoru, a Nesigurni na oba (konfiguracija s 4 procesora u sustavu prikazana
  je na slici \ref{smp_tz})}
  \item{Sigurni softver mijenja procesor na kojem je aktivan, a Nesigurni koristi oba procesora}
\end{enumerate}
Prednost prvog modela je jednostavnost prosljeđivanja prekida Sigurnom softveru, a nedostatak što raspoređivač zadataka
Nesigurnog softvera postaje neefikasan zbog dodjeljivanja procesorskog vremena Sigurnom softveru. Prednost drugog modela je
što rješava problem s raspoređivačom zadataka Nesigurnog softvera, ali prosljeđivanje prekida Sigurnom softveru postaje
kompleksno. Softver nadglednog načina rada se mora pobrinuti da Nesigurni softver procesora kojeg ne koristi i Sigurni softver
ne zatraži zahtjev za zamjenu konteksta. Kad bi zahtjevi bili omogućeni, sustavu bi se povećala ranjivost.
\begin{figure}[H]
  \centering
	\includegraphics[width=400pt]{smp_tz.png}%
	\caption{SMP konfiguracija \textit{TrustZone} ekstenzije \cite{tz_wp}}
	\label{smp_tz}%
\end{figure}

\chapter{Iskorištenje \textit{TrustZone} ekstenzije za ostvarenje LTZVisor monitora virtualnih strojeva}
LTZVisor (\textit{Lightweight TrustZone hypervisor}) je jednostavan monitor virtualnih strojeva otvorenog koda s namjerom
da se potakne rad na proučavanju i implementaciji aplikacija koje iskorištavaju \textit{TrustZone} ekstenziju \cite{ltzvisor}.
Ideja LTZVisora je iskoristiti \textit{TrustZone} ekstenziju kao hardversku podršku za virtualizaciju te na taj način
prezentirati mogućnosti koje nosi \textit{TrustZone} ekstenzija. LTZVisor je dao dobar uvid u mogućnosti \textit{TrustZone}
ekstenzije koja je sada dostupna i u novoj ARMv8-M arhitekturi koja će nesumnjivo biti sve više dostupna u industriji te
će pružati slične mogućnosti. Iskorištenje \textit{TrustZone} ekstenzije omogućava korištenje platforme kao dvostruki virtualni
sustav, odnosno sustav s dva gost virtualna stroja: Sigurni gost i Nesigurni gost. Svaki od gost virtualnih strojeva može
implementirati svoj OS (operacijski sustav). Opisani sustav prikazan je slikom \ref{ltzvisor}.
\begin{figure}[H]
  \centering
	\includegraphics[width=300pt]{ltzvisor.png}%
	\caption{Arhitektura LTZVisor monitora virtualnih strojeva \cite{ltzvisor}}
	\label{ltzvisor}%
\end{figure}
Na slici \ref{ltzvisor} se raspoznaju tri glavne komponente, a to su:
\begin{itemize}
  \item{monitor virtualnih strojeva koji se izvodi u najprivilegiranijem načinu rada procesora (nadglednom načinu rada)}
  \item{Sigurni gost virtualni stroj koji se izvodi u \textit{supervisor} načinu rada Sigurnog svijeta}
  \item{Nesigurni gost virtualni stroj koji se izvodi u \textit{supervisor} načinu rada Nesigurnog svijeta}
\end{itemize}
Iako se i Sigurni i Nesigurni gost virtualni strojevi izvode u \textit{supervisor} načinu rada, nisu jednako privilegirani
(Nesigurni gost nema pristup jednakim resursima kao i Sigurni, dok Sigurni ima pristup većini resursa). Obzirom da
Sigurni gost može upravljati resursima Nesigurnog gosta, Sigurni gost je svjestan virtualizacije. Pokušaj pristupa Nesigurnog
gosta Sigurnom resursu izaziva iznimku monitoru virtualnih strojeva.
Jedna od zadaća monitora virtualnih strojeva je konfiguriranje memorije, prekida i uređaja za gost virtualne strojeve.

\section{Raspoređivanje Sigurnog i Nesigurnog svijeta}
Dodatna zadaća monitora virtualnih strojeva, a veže se uz raspoređivanje Sigurnog i Nesigurnog gosta, je upravljanje s
VMCB (engl. \textit{Virtual Machine Control Block}) blokovima koji su zaduženi za pohranjivanje stanja virtualnih strojeva.

\section{Memorijski podsustav LTZVisora}
\section{Prekidni podsustav LTZVisora}
\section{Razvoj koda za Nesigurni gost virtualni stroj}

\chapter{Postupak prilagođenja LTZVisora za AMP}

\chapter{Postupak prilagođenja LTZVisora za SMP}

\chapter{Zaključak}
Zaključak.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Title}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}
